// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATBUFFERS_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_FLATBUFFERS_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace FlatBuffers {

struct Vector2;

struct Vector3;

struct Line;

struct Polygon;
struct PolygonBuilder;

struct Polyhedron;
struct PolyhedronBuilder;

struct Interval;

struct Id;

struct IdInterval;

struct Box2;

struct Box3;

struct Cover;
struct CoverBuilder;

struct Data;
struct DataBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;

 public:
  Vector2()
      : x_(0),
        y_(0) {
  }
  Vector2(double _x, double _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  Vector3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Line FLATBUFFERS_FINAL_CLASS {
 private:
  FlatBuffers::Vector2 point_;
  FlatBuffers::Vector2 direction_;

 public:
  Line()
      : point_(),
        direction_() {
  }
  Line(const FlatBuffers::Vector2 &_point, const FlatBuffers::Vector2 &_direction)
      : point_(_point),
        direction_(_direction) {
  }
  const FlatBuffers::Vector2 &point() const {
    return point_;
  }
  const FlatBuffers::Vector2 &direction() const {
    return direction_;
  }
};
FLATBUFFERS_STRUCT_END(Line, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Interval FLATBUFFERS_FINAL_CLASS {
 private:
  double min_;
  double max_;

 public:
  Interval()
      : min_(0),
        max_(0) {
  }
  Interval(double _min, double _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  double min() const {
    return flatbuffers::EndianScalar(min_);
  }
  double max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(Interval, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Id FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t bits_;
  uint8_t depth_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  Id()
      : bits_(0),
        depth_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  Id(uint64_t _bits, uint8_t _depth)
      : bits_(flatbuffers::EndianScalar(_bits)),
        depth_(flatbuffers::EndianScalar(_depth)),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  uint64_t bits() const {
    return flatbuffers::EndianScalar(bits_);
  }
  uint8_t depth() const {
    return flatbuffers::EndianScalar(depth_);
  }
};
FLATBUFFERS_STRUCT_END(Id, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) IdInterval FLATBUFFERS_FINAL_CLASS {
 private:
  FlatBuffers::Id id_;
  FlatBuffers::Interval interval_;

 public:
  IdInterval()
      : id_(),
        interval_() {
  }
  IdInterval(const FlatBuffers::Id &_id, const FlatBuffers::Interval &_interval)
      : id_(_id),
        interval_(_interval) {
  }
  const FlatBuffers::Id &id() const {
    return id_;
  }
  const FlatBuffers::Interval &interval() const {
    return interval_;
  }
};
FLATBUFFERS_STRUCT_END(IdInterval, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Box2 FLATBUFFERS_FINAL_CLASS {
 private:
  FlatBuffers::IdInterval phi_;
  FlatBuffers::IdInterval theta_;

 public:
  Box2()
      : phi_(),
        theta_() {
  }
  Box2(const FlatBuffers::IdInterval &_phi, const FlatBuffers::IdInterval &_theta)
      : phi_(_phi),
        theta_(_theta) {
  }
  const FlatBuffers::IdInterval &phi() const {
    return phi_;
  }
  const FlatBuffers::IdInterval &theta() const {
    return theta_;
  }
};
FLATBUFFERS_STRUCT_END(Box2, 64);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Box3 FLATBUFFERS_FINAL_CLASS {
 private:
  FlatBuffers::IdInterval phi_;
  FlatBuffers::IdInterval theta_;
  FlatBuffers::IdInterval alpha_;

 public:
  Box3()
      : phi_(),
        theta_(),
        alpha_() {
  }
  Box3(const FlatBuffers::IdInterval &_phi, const FlatBuffers::IdInterval &_theta, const FlatBuffers::IdInterval &_alpha)
      : phi_(_phi),
        theta_(_theta),
        alpha_(_alpha) {
  }
  const FlatBuffers::IdInterval &phi() const {
    return phi_;
  }
  const FlatBuffers::IdInterval &theta() const {
    return theta_;
  }
  const FlatBuffers::IdInterval &alpha() const {
    return alpha_;
  }
};
FLATBUFFERS_STRUCT_END(Box3, 96);

struct Polygon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolygonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINES = 4
  };
  const flatbuffers::Vector<const FlatBuffers::Line *> *lines() const {
    return GetPointer<const flatbuffers::Vector<const FlatBuffers::Line *> *>(VT_LINES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.EndTable();
  }
};

struct PolygonBuilder {
  typedef Polygon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lines(flatbuffers::Offset<flatbuffers::Vector<const FlatBuffers::Line *>> lines) {
    fbb_.AddOffset(Polygon::VT_LINES, lines);
  }
  explicit PolygonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Polygon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Polygon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Polygon> CreatePolygon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const FlatBuffers::Line *>> lines = 0) {
  PolygonBuilder builder_(_fbb);
  builder_.add_lines(lines);
  return builder_.Finish();
}

inline flatbuffers::Offset<Polygon> CreatePolygonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<FlatBuffers::Line> *lines = nullptr) {
  auto lines__ = lines ? _fbb.CreateVectorOfStructs<FlatBuffers::Line>(*lines) : 0;
  return FlatBuffers::CreatePolygon(
      _fbb,
      lines__);
}

struct Polyhedron FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolyhedronBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERTICES = 4
  };
  const flatbuffers::Vector<const FlatBuffers::Vector3 *> *vertices() const {
    return GetPointer<const flatbuffers::Vector<const FlatBuffers::Vector3 *> *>(VT_VERTICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.VerifyVector(vertices()) &&
           verifier.EndTable();
  }
};

struct PolyhedronBuilder {
  typedef Polyhedron Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<const FlatBuffers::Vector3 *>> vertices) {
    fbb_.AddOffset(Polyhedron::VT_VERTICES, vertices);
  }
  explicit PolyhedronBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Polyhedron> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Polyhedron>(end);
    return o;
  }
};

inline flatbuffers::Offset<Polyhedron> CreatePolyhedron(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const FlatBuffers::Vector3 *>> vertices = 0) {
  PolyhedronBuilder builder_(_fbb);
  builder_.add_vertices(vertices);
  return builder_.Finish();
}

inline flatbuffers::Offset<Polyhedron> CreatePolyhedronDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<FlatBuffers::Vector3> *vertices = nullptr) {
  auto vertices__ = vertices ? _fbb.CreateVectorOfStructs<FlatBuffers::Vector3>(*vertices) : 0;
  return FlatBuffers::CreatePolyhedron(
      _fbb,
      vertices__);
}

struct Cover FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CoverBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FULL = 4,
    VT_BOX3 = 6,
    VT_BOX2S = 8
  };
  bool full() const {
    return GetField<uint8_t>(VT_FULL, 0) != 0;
  }
  const FlatBuffers::Box3 *box3() const {
    return GetStruct<const FlatBuffers::Box3 *>(VT_BOX3);
  }
  const flatbuffers::Vector<const FlatBuffers::Box2 *> *box2s() const {
    return GetPointer<const flatbuffers::Vector<const FlatBuffers::Box2 *> *>(VT_BOX2S);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FULL, 1) &&
           VerifyField<FlatBuffers::Box3>(verifier, VT_BOX3, 8) &&
           VerifyOffset(verifier, VT_BOX2S) &&
           verifier.VerifyVector(box2s()) &&
           verifier.EndTable();
  }
};

struct CoverBuilder {
  typedef Cover Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_full(bool full) {
    fbb_.AddElement<uint8_t>(Cover::VT_FULL, static_cast<uint8_t>(full), 0);
  }
  void add_box3(const FlatBuffers::Box3 *box3) {
    fbb_.AddStruct(Cover::VT_BOX3, box3);
  }
  void add_box2s(flatbuffers::Offset<flatbuffers::Vector<const FlatBuffers::Box2 *>> box2s) {
    fbb_.AddOffset(Cover::VT_BOX2S, box2s);
  }
  explicit CoverBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cover> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cover>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cover> CreateCover(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool full = false,
    const FlatBuffers::Box3 *box3 = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<const FlatBuffers::Box2 *>> box2s = 0) {
  CoverBuilder builder_(_fbb);
  builder_.add_box2s(box2s);
  builder_.add_box3(box3);
  builder_.add_full(full);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cover> CreateCoverDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool full = false,
    const FlatBuffers::Box3 *box3 = nullptr,
    const std::vector<FlatBuffers::Box2> *box2s = nullptr) {
  auto box2s__ = box2s ? _fbb.CreateVectorOfStructs<FlatBuffers::Box2>(*box2s) : 0;
  return FlatBuffers::CreateCover(
      _fbb,
      full,
      box3,
      box2s__);
}

struct Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESCRIPTION = 4,
    VT_HOLE = 6,
    VT_PLUG = 8,
    VT_COVERS = 10
  };
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const FlatBuffers::Polyhedron *hole() const {
    return GetPointer<const FlatBuffers::Polyhedron *>(VT_HOLE);
  }
  const FlatBuffers::Polyhedron *plug() const {
    return GetPointer<const FlatBuffers::Polyhedron *>(VT_PLUG);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FlatBuffers::Cover>> *covers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FlatBuffers::Cover>> *>(VT_COVERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_HOLE) &&
           verifier.VerifyTable(hole()) &&
           VerifyOffset(verifier, VT_PLUG) &&
           verifier.VerifyTable(plug()) &&
           VerifyOffset(verifier, VT_COVERS) &&
           verifier.VerifyVector(covers()) &&
           verifier.VerifyVectorOfTables(covers()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  typedef Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Data::VT_DESCRIPTION, description);
  }
  void add_hole(flatbuffers::Offset<FlatBuffers::Polyhedron> hole) {
    fbb_.AddOffset(Data::VT_HOLE, hole);
  }
  void add_plug(flatbuffers::Offset<FlatBuffers::Polyhedron> plug) {
    fbb_.AddOffset(Data::VT_PLUG, plug);
  }
  void add_covers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBuffers::Cover>>> covers) {
    fbb_.AddOffset(Data::VT_COVERS, covers);
  }
  explicit DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<Data> CreateData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<FlatBuffers::Polyhedron> hole = 0,
    flatbuffers::Offset<FlatBuffers::Polyhedron> plug = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FlatBuffers::Cover>>> covers = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_covers(covers);
  builder_.add_plug(plug);
  builder_.add_hole(hole);
  builder_.add_description(description);
  return builder_.Finish();
}

inline flatbuffers::Offset<Data> CreateDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *description = nullptr,
    flatbuffers::Offset<FlatBuffers::Polyhedron> hole = 0,
    flatbuffers::Offset<FlatBuffers::Polyhedron> plug = 0,
    const std::vector<flatbuffers::Offset<FlatBuffers::Cover>> *covers = nullptr) {
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto covers__ = covers ? _fbb.CreateVector<flatbuffers::Offset<FlatBuffers::Cover>>(*covers) : 0;
  return FlatBuffers::CreateData(
      _fbb,
      description__,
      hole,
      plug,
      covers__);
}

inline const FlatBuffers::Data *GetData(const void *buf) {
  return flatbuffers::GetRoot<FlatBuffers::Data>(buf);
}

inline const FlatBuffers::Data *GetSizePrefixedData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FlatBuffers::Data>(buf);
}

inline bool VerifyDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FlatBuffers::Data>(nullptr);
}

inline bool VerifySizePrefixedDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FlatBuffers::Data>(nullptr);
}

inline void FinishDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FlatBuffers::Data> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FlatBuffers::Data> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FlatBuffers

#endif  // FLATBUFFERS_GENERATED_FLATBUFFERS_FLATBUFFERS_H_
